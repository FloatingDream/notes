# Git

## Git 简介

> Git 是一个 分布式版本控制系统，客户端并不只提取最新版本的文件快照，而是把整个代码仓库完整的镜像下来，每一次的提取操作都是对代码仓库的完整备份；许多这类系统可以指定若干个不同的远程代码仓库进行交互，分别和不同的工作小组的人相互协作，并可以根据需求设定不同的协作流程这是之前的集中式系统无法实现的。

**目标：**

* 速度
* 简单的设计
* 对非线性开发模式的强力支持（允许上千个并行开发的分支）
* 完全分布式
* 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数量）

### 普通版本管理与 Git 版本管理差异

![ ](https://git-scm.com/figures/18333fig0104-tn.png)

普通版本管理记录的是每次的版本差异，即那些文件做了那些更新

![ ](https://git-scm.com/figures/18333fig0105-tn.png)

Git 每个版本都是一个整个文件的快照，记录在一个微型的文件系统中，每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件做一次快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，只做个链接指向上一个快照。

### 几乎所有操作都是本地运行（分布式，不依赖于主机）

### 时刻保持数据完整性

在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。

### 文件的三种状态

* 已提交（committled）：便是该文件已经被安全保存在本地数据库中
* 已修改（modified）：已修改表示修改了某个文件还没提交保存
* 已暂存（staged）：表示把已修改的文件放在下次提交时要保存的清单中

### 文件流转的三个工作区

* Git 工作目录：git目录，他是 Git 用来保存元数据和对象数据库的地方 .git 的目录；每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。从 .git 中取出某个版本的所有文件和目录，用来开始后续工作的地方叫做工作目录。
* 暂存区域：指的是个文件 一般存放在 Git 目录中，有时候人们会把这个文件叫做索引文件。
* 本地仓库：整个项目文件与 .git。

![ ](https://git-scm.com/figures/18333fig0106-tn.png)

### 基本的 Git 工作流程如下

1. 在工作目录中修改某些文件。
2. 对修改后的文件进行快照，然后保存到暂存区域。
3. 提交更新，将保存在暂存区域的文件快照永久转存到 Git 目录中。

### Git 工作环境配置

配置文件分别有如下三种：

* `/etc/gitconfig` 文件：全局配置；使用 `git config --system` 时读写的配置文件
* `~/.gitconfig` 文件：用户目录下的用户配置文件；使用 `git config --global` 时读写的文件
* `.git/config` 文件：存放在项目文件下，针对某个项目的配置文件

常用配置项：
 
* 用户信息:

```bash
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

* 文本编辑器

```bash
$ git config --global core.editor emacs
```

* 差异分析工具

```bash
$ git config --global merge.tool vimdiff
```

* 查看配置信息

```bash
$ git config --list  //查看所有信息
$ git config user.name  //查看某项信息
```

## Git 基础

### 取得项目 Git 仓库

1\. 在工作目录中初始化新仓库

```bash
$ git init  //创建仓库
$ git add *  //暂存文件
$ git commit -m 'init project'  //提交更新
```

2\. 从现有的仓库克隆

```bash
$ git clone [url] [alias](可选)
$ git clone git://github.com/schacon/grit.git mygrit // 定义新建项目目录名称 mygirt
```

### 提交仓库

文件状态：

* 未跟踪：从未有快照记录的文件
* 已跟踪：已经纳入版本管理的文件

  * 未更新：已提交的文件
  * 已修改：与上次快照不一致被修改过的文件
  * 已放入暂存区：放入暂存区未提交的文件

![ ](https://git-scm.com/figures/18333fig0201-tn.png)

#### 检查当前文件状态

```bash
$ git status
```

#### 跟踪新文件

```bash
// git add 后面跟需要跟踪的文件，可用通配符
$ git add README
$ git add *
```

> 其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了

#### 暂存已修改文件

```bash
$ git add README
```

> 这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等

#### 忽略某些文件

创建一个 .gitignore 文件，列出要忽略的文件。

```bash
# 此为注释 – 将被 Git 忽略
# 忽略所有 .a 结尾的文件
*.a
# 但 lib.a 除外
!lib.a
# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO
# 忽略 build/ 目录下的所有文件
build/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录下所有扩展名为 txt 的文件
doc/**/*.txt
```

#### 查看已暂存和未暂存的更新

实际上 git status 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令。

```bash
$ git diff //此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容
$ git diff --cached  //要看已经暂存起来的文件和上次提交时的快照之间的差异
$ git diff --staged // 1.6.1 版本后支持 与 --cached 一样
```

#### 提交更新

```bash
$ git commit  // 运行编辑器编写 提交信息
$ git commit -m "test" // 直接跟提交说明
```

> 记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。


#### 跳过使用暂存区域

Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：

```bash
$ git commit -a //注意这个方法只提交了已跟踪过的文件
```

#### 移除文件

要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 
`git rm` 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

```bash
$ git rm [name] //移除文件
$ git rm --cached [name] //从暂存区移除文件
$ git commit //提交文件
```

> 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。

#### 移动文件

```bash
$ git mv file_form file_to

// 等于如下命令
$ mv README.txt README
$ git rm README.txt
$ git add README
```

### 查看提交历史

在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 `git log` 命令查看

> 建议使用可视化软件查看

### 撤销操作

#### 修改最后一次提交

撤销刚刚的提交操作，可以使用`--amend` 选项重新提交：

```bash
$ git commit --amend
```

> 此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。

#### 取消已经暂存的文件

```bash
$ git reset HEAD [file]
```

> 这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的 stashing 和分支来处理，应该会更好些。

### 远程仓库的使用

#### 查看当前远程仓库

```bash
$ git remote   // git 使用 origin 为默认参考
$ git remote -v // -v 选项，显示出对应的克隆地址
```

> 地址是 SSH URL 链接的仓库才能推送数据，其他只能克隆数据

#### 添加远程仓库

```bash
$ git remote add [shorname] [url] // shorname 名称可以任意起不要重复就行，后续操作可以代表这个地址
```

#### 从远程仓库抓取数据

```bash
$ git fetch [remote-name] // 拉取本地仓库没有的数据
```

> 如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。

`git pull`

> 可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。

#### 推送数据到远程仓库

```bash
$ git push [remote-name] [breach-name]
$ git push orign master // 克隆仓库默认的名称
```

> 只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。

#### 查看远程仓库信息

```bash
$ git remote show [remote-name]
```

> 列出远程仓库的详细信息，还有分支的状态

#### 远程仓库的删除和重命名

```bash
$ git remote rename [old-name] [new-name]
$ git remote rm [name]
```

> 重命名仓库，对应分支名也会发生改变

### 打标签

#### 显示已有的标签

```bash
$ git tag  // 按标签字母顺序显示
$ git tag -l 'v1.4.1.*' // 列出 1.4.1系列的版本
```

#### 新建标签

> Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。

##### 含附注的标签

```bash
$ git tag -a v1.4 -m 'my version 1.4' //-m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。 (取 annotated 的首字母)
```

##### 签署标签

> 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可

```bash
$ git tag -s v1.5 -m 'my signed 1.5 tag'
```

##### 轻量级标签

> 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可

##### 验证标签

> 可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证

##### 后期加注标签

```bash
$ git tag -a v1.2 9fceb02  // 对应提交对象的效验和 （前几位就行）
```

##### 分享标签

> 默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。

```bash
$ git push origin v1.5  
$ git push origin --tags  //一次推送所有本地标签
```

## 分支

> 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。

### 理解 Git 分支

> 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先

我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域

现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。

![ ](https://git-scm.com/figures/18333fig0301-tn.png)

作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成如下的样子：

![ ](https://git-scm.com/figures/18333fig0302-tn.png)

Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。

![ ](https://git-scm.com/figures/18333fig0303-tn.png)


使用 `git breach [branch-name]` 新建分支，会创建一个新分支指针指向新该版本，git 还有一个 `HEAD` 的特殊指针，指向你正在工作中的本地分支的指针。

![ ](https://git-scm.com/figures/18333fig0305-tn.png)

使用 `git checkout [branch-name]` 切换分支

![ ](https://git-scm.com/figures/18333fig0306-tn.png)

不同流向的分支历史

![ ](https://git-scm.com/figures/18333fig0309-tn.png)

### 分支的新建与合并

#### 分支的新建与切换

```bash
$ git checkout -b [branch-name] //新建并切换分支
$ git branch [branch-name] //新建分支
$ git checkout [branch-name] //切换分支
$ git branch -d [branch-name] //删除分支
```

> 切换分支时 Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。

单线分支合并

> 如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。

#### 分支的合并

```
$ git checkout [branch-name]  //主分支
$ git merge [branch-name1] //需要合并的分支
```

多线分支合并

> Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象,这个对象有两个祖先。

![ ](https://git-scm.com/figures/18333fig0316-tn.png)

![ ](https://git-scm.com/figures/18333fig0317-tn.png)

#### 遇到冲突时的分支合并

有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起；合并的时候 Git 会提示 `Merge conflict` 停止提交等待处理冲突。

使用 `git status` 查看哪些文件在合并的时候发生冲突。任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。

两个分支不同地方使用 `======` 分割开，解决冲突的办法无非是二者选其一或者由你亲自整合到一起；并删除 Git 在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。再运行一次 git status 来确认所有冲突都已解决。如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突。

### 分支管理

```bash
$ git branch //列出当前所有分支;分支前有 * 号的是当前分支
$ gti branch -v //查看各个分支最后一个提交的对象
$ git branch --merged //查看哪些分支已经合并入当前分支
$ git branch --no-merged //查看哪些没有合并
```

> 未合并的分支，删除会损失尚未合并的信息，默认禁止删除可以添加 -D 选项强制删除。

### 利用分支进行开发的工作流程

#### 长期分支

由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。

![ ](https://git-scm.com/figures/18333fig0318-tn.png)

> 稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前

流水线的形式

![ ](https://git-scm.com/figures/18333fig0319-tn.png)

> 使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。

#### 特征分支

在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。

![ ](https://git-scm.com/figures/18333fig0320-tn.png)

合并；舍弃iss91

![ ](https://git-scm.com/figures/18333fig0321-tn.png)

> 请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。

### 远程分支

远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。

![ ](https://git-scm.com/figures/18333fig0322-tn.png)

> 一次 Git 克隆会建立你本地分支 master 和远程分支 origin/master,并且他们都指向同一个分支。


![ ](https://git-scm.com/figures/18333fig0323-tn.png)

> 如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而与此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动。

![ ](https://git-scm.com/figures/18333fig0324-tn.png)

> 可以运行 `git fetch origin` 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上。

#### 多个远程分支

在一个项目中存在在多个远程分支

![ ](https://git-scm.com/figures/18333fig0325-tn.png)

获取数据后你在本地有了一个指向 teamone 服务器上 master 分支的索引。

![ ](https://git-scm.com/figures/18333fig0326-tn.png)

#### 推送本地分支

```bash
$ git push [remote-name] [breach-name]//默认是本地分支与远程分支同名
$ git push [remote-name] [local-breach-name]:[origin-breach-name]
```

> 推送之后同步分支，只是有一个无法移动的指针，无法编辑该分支。需要合并到当前分支，或者在远程分支基础上新建一个分支。（也就是无法直接编辑远程分支，只能编辑对应的本地分支或者合并到本地分支中）

#### 跟踪远程分支

从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。

在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支

使用 `git checkout -b [分支名] [远程名]/[分支名]`,创建跟踪分支。

#### 删除远程分支

如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：`git push [远程名] :[分支名]`。

### 分支的变基

#### 基本的变基操作

通过 merge  合并分支

![ ](https://git-scm.com/figures/18333fig0328-tn.png)

你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做变基（rebase）。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。

![ ](https://git-scm.com/figures/18333fig0329-tn.png)

#### 有趣的变基

![ ](https://git-scm.com/figures/18333fig0331-tn.png)

假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 client 分支而非 server 分支的改变（即 C8 和 C9），跳过 server 直接放到 master 分支中重演一遍，但这需要用 git rebase 的 --onto 选项指定新的基底分支 master：

`$ git rebase --onto master server client`

![ ](https://git-scm.com/figures/18333fig0332-tn.png)


#### 变基的风险

> 一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行变基操作。(编辑操作会抛弃之前提交的对象生成新对象，其他人的操作可能是基于该对象进行)

在进行变基的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。

![ ](https://git-scm.com/figures/18333fig0339-tn.png)

> c8 中同时包含 C4' 和 C4；但是 C4' 中已经包含了 C4；发生重复；
> 多人协作的时候不要修改提交远程仓库中的对象

## 分布式Git

### 分布式工作流程

#### 集中式工作流

集中式工作流程使用的都是单点协作模型。一个存放代码仓库的中心服务器，可以接受所有开发者提交的代码。所有的开发者都是普通的节点，作为中心集线器的消费者，平时的工作就是和中心仓库同步数据

![ ](https://git-scm.com/figures/18333fig0501-tn.png)

> 如果两个开发者从中心仓库克隆代码下来，同时作了一些修订，那么只有第一个开发者可以顺利地把数据推送到共享服务器。第二个开发者在提交他的修订之前，必须先下载合并服务器上的数据，解决冲突之后才能推送数据到共享服务器上。

#### 集成管理员工作流

由于 Git 允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以从别人的仓库中提取他们的更新过来。这种情形通常都会有个代表着官方发布的项目仓库（blessed repository），开发者们由此仓库克隆出一个自己的公共仓库（developer public），然后将自己的提交推送上去，请求官方仓库的维护者拉取更新合并到主项目。维护者在自己的本地也有个克隆仓库（integration manager），他可以将你的公共仓库作为远程仓库添加进来，经过测试无误后合并到主干分支，然后再推送到官方仓库。

![ ](https://git-scm.com/figures/18333fig0502-tn.png)
 
#### 司令官和副官工作流

这其实是上一种工作流的变体。一般超大型的项目才会用到这样的工作方式，像是拥有数百协作开发者的 Linux 内核项目就是如此。各个集成管理员分别负责集成项目中的特定部分，所以称为副官（lieutenant）。而所有这些集成管理员头上还有一位负责统筹的总集成管理员，称为司令官（dictator）。司令官维护的仓库用于提供所有协作者拉取最新集成的项目代码。

![ ](https://git-scm.com/figures/18333fig0503-tn.png)

### 为项目做贡献

#### 提交指南

1\. 不要在更新中提交多余的空格，Git 有种检查此类问题的方法，在提交之前，先运行 `git diff --check`，会把可能的多余白字符修正列出来。

2\. 请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。

3\. 最后需要谨记的是提交说明的撰写,提交说明最好限制在一行以内，50 个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解。

```js
// 提交说明模版
本次更新的简要描述（50 个字符以内）

如果必要，此处展开详尽阐述。段落宽度限定在 72 个字符以内。
某些情况下，第一行的简要描述将用作邮件标题，其余部分作为邮件正文。
其间的空行是必要的，以区分两者（当然没有正文另当别论）。
如果并在一起，rebase 这样的工具就可能会迷惑。

另起空行后，再进一步补充其他说明。

 - 可以使用这样的条目列举式。

 - 一般以单个空格紧跟短划线或者星号作为每项条目的起始符。每个条目间用一空行隔开。
   不过这里按自己项目的约定，可以略作变化。
```

#### 简单项目工作

![ ](https://git-scm.com/figures/18333fig0510-tn.png)

![ ](https://git-scm.com/figures/18333fig0511-tn.png)

> 先在自己的特性分支中工作一段时间，完成后合并到自己的 master 分支；然后下载合并 origin/master 上的更新（如果有的话），再推回远程服务器。

查看远程库信息，使用git remote -v；

本地新建的分支如果不推送到远程，对其他人就是不可见的；

从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；

在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；

建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；

从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。

#### 多小组协作项目

![ ](https://git-scm.com/figures/18333fig0514-tn.png)

工作流程时序

![ ](https://git-scm.com/figures/18333fig0515-tn.png)

### 项目的管理

#### 使用特性分支进行工作

如果想要集成新的代码进来，最好局限在特性分支上做。临时的特性分支可以让你随意尝试，进退自如。比如碰上无法正常工作的补丁，可以先搁在那边，直到有时间仔细核查修复为止。创建的分支可以用相关的主题关键字命名，比如 ruby_client 或者其它类似的描述性词语，以帮助将来回忆。Git 项目本身还时常把分支名称分置于不同命名空间下，比如 sc/ruby_client 就说明这是 sc 这个人贡献的。

> 工作进行一半，还没办法提交，需要紧急修复一个bug，可以使用 `git stash` 命令将当前工作现场‘储藏’。后期使用 `git stash list` 参看储藏的现场 `git stash apply` 恢复，但是恢复后储藏的内容并不删除，需要使用 `git stash drop` 删除或 `git stash pop` 恢复同时删除。

修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；

当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；

在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。
